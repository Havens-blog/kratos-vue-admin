// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: base.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ApiBase with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ApiBase) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApiBase with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ApiBaseMultiError, or nil if none found.
func (m *ApiBase) ValidateAll() error {
	return m.validate(true)
}

func (m *ApiBase) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	// no validation rules for Method

	if len(errors) > 0 {
		return ApiBaseMultiError(errors)
	}

	return nil
}

// ApiBaseMultiError is an error wrapping multiple validation errors returned
// by ApiBase.ValidateAll() if the designated constraints aren't met.
type ApiBaseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApiBaseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApiBaseMultiError) AllErrors() []error { return m }

// ApiBaseValidationError is the validation error returned by ApiBase.Validate
// if the designated constraints aren't met.
type ApiBaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApiBaseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApiBaseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApiBaseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApiBaseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApiBaseValidationError) ErrorName() string { return "ApiBaseValidationError" }

// Error satisfies the builtin error interface
func (e ApiBaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApiBase.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApiBaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApiBaseValidationError{}

// Validate checks the field values on DeptTree with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeptTree) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeptTree with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeptTreeMultiError, or nil
// if none found.
func (m *DeptTree) ValidateAll() error {
	return m.validate(true)
}

func (m *DeptTree) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeptId

	// no validation rules for ParentId

	// no validation rules for DeptPath

	// no validation rules for DeptName

	// no validation rules for Sort

	// no validation rules for Leader

	// no validation rules for Phone

	// no validation rules for Email

	// no validation rules for Status

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeptTreeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeptTreeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeptTreeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeptTreeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeptTreeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeptTreeValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeptTreeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeptTreeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeptTreeValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeptTreeMultiError(errors)
	}

	return nil
}

// DeptTreeMultiError is an error wrapping multiple validation errors returned
// by DeptTree.ValidateAll() if the designated constraints aren't met.
type DeptTreeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeptTreeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeptTreeMultiError) AllErrors() []error { return m }

// DeptTreeValidationError is the validation error returned by
// DeptTree.Validate if the designated constraints aren't met.
type DeptTreeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeptTreeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeptTreeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeptTreeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeptTreeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeptTreeValidationError) ErrorName() string { return "DeptTreeValidationError" }

// Error satisfies the builtin error interface
func (e DeptTreeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeptTree.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeptTreeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeptTreeValidationError{}

// Validate checks the field values on RoleData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoleDataMultiError, or nil
// if none found.
func (m *RoleData) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoleId

	// no validation rules for RoleName

	// no validation rules for Status

	// no validation rules for RoleKey

	// no validation rules for RoleSort

	// no validation rules for DataScope

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for Remark

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoleDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoleDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoleDataValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoleDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoleDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoleDataValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RoleDataMultiError(errors)
	}

	return nil
}

// RoleDataMultiError is an error wrapping multiple validation errors returned
// by RoleData.ValidateAll() if the designated constraints aren't met.
type RoleDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleDataMultiError) AllErrors() []error { return m }

// RoleDataValidationError is the validation error returned by
// RoleData.Validate if the designated constraints aren't met.
type RoleDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleDataValidationError) ErrorName() string { return "RoleDataValidationError" }

// Error satisfies the builtin error interface
func (e RoleDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleDataValidationError{}

// Validate checks the field values on ApiData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ApiData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApiData with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ApiDataMultiError, or nil if none found.
func (m *ApiData) ValidateAll() error {
	return m.validate(true)
}

func (m *ApiData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Path

	// no validation rules for Description

	// no validation rules for ApiGroup

	// no validation rules for Method

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApiDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApiDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApiDataValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApiDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApiDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApiDataValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApiDataMultiError(errors)
	}

	return nil
}

// ApiDataMultiError is an error wrapping multiple validation errors returned
// by ApiData.ValidateAll() if the designated constraints aren't met.
type ApiDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApiDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApiDataMultiError) AllErrors() []error { return m }

// ApiDataValidationError is the validation error returned by ApiData.Validate
// if the designated constraints aren't met.
type ApiDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApiDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApiDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApiDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApiDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApiDataValidationError) ErrorName() string { return "ApiDataValidationError" }

// Error satisfies the builtin error interface
func (e ApiDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApiData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApiDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApiDataValidationError{}

// Validate checks the field values on MenuTreeAuth with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuTreeAuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuTreeAuth with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuTreeAuthMultiError, or
// nil if none found.
func (m *MenuTreeAuth) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuTreeAuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Redirect

	// no validation rules for Component

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuTreeAuthValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuTreeAuthValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuTreeAuthValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuTreeAuthValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuTreeAuthValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuTreeAuthValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ParentId

	if len(errors) > 0 {
		return MenuTreeAuthMultiError(errors)
	}

	return nil
}

// MenuTreeAuthMultiError is an error wrapping multiple validation errors
// returned by MenuTreeAuth.ValidateAll() if the designated constraints aren't met.
type MenuTreeAuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuTreeAuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuTreeAuthMultiError) AllErrors() []error { return m }

// MenuTreeAuthValidationError is the validation error returned by
// MenuTreeAuth.Validate if the designated constraints aren't met.
type MenuTreeAuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuTreeAuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuTreeAuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuTreeAuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuTreeAuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuTreeAuthValidationError) ErrorName() string { return "MenuTreeAuthValidationError" }

// Error satisfies the builtin error interface
func (e MenuTreeAuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuTreeAuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuTreeAuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuTreeAuthValidationError{}

// Validate checks the field values on MenuTreeMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuTreeMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuTreeMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuTreeMetaMultiError, or
// nil if none found.
func (m *MenuTreeMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuTreeMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for IsLink

	// no validation rules for IsHide

	// no validation rules for IsKeepAlive

	// no validation rules for IsAffix

	// no validation rules for IsIframe

	// no validation rules for Icon

	if len(errors) > 0 {
		return MenuTreeMetaMultiError(errors)
	}

	return nil
}

// MenuTreeMetaMultiError is an error wrapping multiple validation errors
// returned by MenuTreeMeta.ValidateAll() if the designated constraints aren't met.
type MenuTreeMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuTreeMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuTreeMetaMultiError) AllErrors() []error { return m }

// MenuTreeMetaValidationError is the validation error returned by
// MenuTreeMeta.Validate if the designated constraints aren't met.
type MenuTreeMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuTreeMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuTreeMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuTreeMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuTreeMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuTreeMetaValidationError) ErrorName() string { return "MenuTreeMetaValidationError" }

// Error satisfies the builtin error interface
func (e MenuTreeMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuTreeMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuTreeMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuTreeMetaValidationError{}

// Validate checks the field values on MenuTree with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuTree) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuTree with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuTreeMultiError, or nil
// if none found.
func (m *MenuTree) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuTree) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MenuId

	// no validation rules for MenuName

	// no validation rules for Title

	// no validation rules for ParentId

	// no validation rules for Sort

	// no validation rules for Icon

	// no validation rules for Path

	// no validation rules for Component

	// no validation rules for IsIframe

	// no validation rules for IsLink

	// no validation rules for MenuType

	// no validation rules for IsHide

	// no validation rules for IsKeepAlive

	// no validation rules for IsAffix

	// no validation rules for Permission

	// no validation rules for Status

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for Remark

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuTreeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuTreeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuTreeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuTreeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuTreeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuTreeValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuTreeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuTreeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuTreeValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MenuTreeMultiError(errors)
	}

	return nil
}

// MenuTreeMultiError is an error wrapping multiple validation errors returned
// by MenuTree.ValidateAll() if the designated constraints aren't met.
type MenuTreeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuTreeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuTreeMultiError) AllErrors() []error { return m }

// MenuTreeValidationError is the validation error returned by
// MenuTree.Validate if the designated constraints aren't met.
type MenuTreeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuTreeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuTreeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuTreeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuTreeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuTreeValidationError) ErrorName() string { return "MenuTreeValidationError" }

// Error satisfies the builtin error interface
func (e MenuTreeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuTree.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuTreeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuTreeValidationError{}

// Validate checks the field values on SimpleMenu with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SimpleMenu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SimpleMenu with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SimpleMenuMultiError, or
// nil if none found.
func (m *SimpleMenu) ValidateAll() error {
	return m.validate(true)
}

func (m *SimpleMenu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MenuId

	// no validation rules for MenuName

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SimpleMenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SimpleMenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SimpleMenuValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SimpleMenuMultiError(errors)
	}

	return nil
}

// SimpleMenuMultiError is an error wrapping multiple validation errors
// returned by SimpleMenu.ValidateAll() if the designated constraints aren't met.
type SimpleMenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SimpleMenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SimpleMenuMultiError) AllErrors() []error { return m }

// SimpleMenuValidationError is the validation error returned by
// SimpleMenu.Validate if the designated constraints aren't met.
type SimpleMenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SimpleMenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SimpleMenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SimpleMenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SimpleMenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SimpleMenuValidationError) ErrorName() string { return "SimpleMenuValidationError" }

// Error satisfies the builtin error interface
func (e SimpleMenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSimpleMenu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SimpleMenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SimpleMenuValidationError{}

// Validate checks the field values on UserData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserDataMultiError, or nil
// if none found.
func (m *UserData) ValidateAll() error {
	return m.validate(true)
}

func (m *UserData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for NickName

	// no validation rules for Phone

	// no validation rules for RoleId

	// no validation rules for Salt

	// no validation rules for Avatar

	// no validation rules for Sex

	// no validation rules for Email

	// no validation rules for DeptId

	// no validation rules for PostId

	// no validation rules for RoleIds

	// no validation rules for PostIds

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	// no validation rules for Remark

	// no validation rules for Status

	// no validation rules for Username

	// no validation rules for Password

	// no validation rules for RoleName

	// no validation rules for DeptName

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserDataValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserDataValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Secret

	// no validation rules for Qrcode

	if len(errors) > 0 {
		return UserDataMultiError(errors)
	}

	return nil
}

// UserDataMultiError is an error wrapping multiple validation errors returned
// by UserData.ValidateAll() if the designated constraints aren't met.
type UserDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserDataMultiError) AllErrors() []error { return m }

// UserDataValidationError is the validation error returned by
// UserData.Validate if the designated constraints aren't met.
type UserDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserDataValidationError) ErrorName() string { return "UserDataValidationError" }

// Error satisfies the builtin error interface
func (e UserDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserDataValidationError{}

// Validate checks the field values on PostData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PostData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PostDataMultiError, or nil
// if none found.
func (m *PostData) ValidateAll() error {
	return m.validate(true)
}

func (m *PostData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PostId

	// no validation rules for PostName

	// no validation rules for PostCode

	// no validation rules for Sort

	// no validation rules for Status

	// no validation rules for Remark

	// no validation rules for CreateBy

	// no validation rules for UpdateBy

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostDataValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostDataValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PostDataMultiError(errors)
	}

	return nil
}

// PostDataMultiError is an error wrapping multiple validation errors returned
// by PostData.ValidateAll() if the designated constraints aren't met.
type PostDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostDataMultiError) AllErrors() []error { return m }

// PostDataValidationError is the validation error returned by
// PostData.Validate if the designated constraints aren't met.
type PostDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostDataValidationError) ErrorName() string { return "PostDataValidationError" }

// Error satisfies the builtin error interface
func (e PostDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostDataValidationError{}

// Validate checks the field values on DeptData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeptData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeptData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeptDataMultiError, or nil
// if none found.
func (m *DeptData) ValidateAll() error {
	return m.validate(true)
}

func (m *DeptData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeptDataValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeptDataValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeptDataValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DeptId

	// no validation rules for DeptName

	// no validation rules for DeptPath

	// no validation rules for Email

	// no validation rules for Leader

	// no validation rules for ParentId

	// no validation rules for Phone

	// no validation rules for Short

	// no validation rules for Status

	// no validation rules for CreateBy

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeptDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeptDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeptDataValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeptDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeptDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeptDataValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeptDataMultiError(errors)
	}

	return nil
}

// DeptDataMultiError is an error wrapping multiple validation errors returned
// by DeptData.ValidateAll() if the designated constraints aren't met.
type DeptDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeptDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeptDataMultiError) AllErrors() []error { return m }

// DeptDataValidationError is the validation error returned by
// DeptData.Validate if the designated constraints aren't met.
type DeptDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeptDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeptDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeptDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeptDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeptDataValidationError) ErrorName() string { return "DeptDataValidationError" }

// Error satisfies the builtin error interface
func (e DeptDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeptData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeptDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeptDataValidationError{}

// Validate checks the field values on SensitiveInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SensitiveInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SensitiveInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SensitiveInfoMultiError, or
// nil if none found.
func (m *SensitiveInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SensitiveInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Word

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SensitiveInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SensitiveInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SensitiveInfoValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SensitiveInfoMultiError(errors)
	}

	return nil
}

// SensitiveInfoMultiError is an error wrapping multiple validation errors
// returned by SensitiveInfo.ValidateAll() if the designated constraints
// aren't met.
type SensitiveInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SensitiveInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SensitiveInfoMultiError) AllErrors() []error { return m }

// SensitiveInfoValidationError is the validation error returned by
// SensitiveInfo.Validate if the designated constraints aren't met.
type SensitiveInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SensitiveInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SensitiveInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SensitiveInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SensitiveInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SensitiveInfoValidationError) ErrorName() string { return "SensitiveInfoValidationError" }

// Error satisfies the builtin error interface
func (e SensitiveInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSensitiveInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SensitiveInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SensitiveInfoValidationError{}

// Validate checks the field values on UserInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoMultiError, or nil
// if none found.
func (m *UserInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for Nickname

	// no validation rules for FaceURL

	// no validation rules for Gender

	// no validation rules for PhoneNumber

	// no validation rules for Email

	// no validation rules for Motto

	// no validation rules for Platform

	if all {
		switch v := interface{}(m.GetBirth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "Birth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "Birth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBirth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "Birth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Account

	// no validation rules for Level

	// no validation rules for LastLoginIp

	// no validation rules for FriendCount

	// no validation rules for GroupCount

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetLastLoginTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "LastLoginTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "LastLoginTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastLoginTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "LastLoginTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFunctionStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "FunctionStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "FunctionStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFunctionStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "FunctionStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIpList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "IpList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "IpList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIpList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "IpList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AllowAddFriend

	// no validation rules for AllowCreateGroup

	// no validation rules for GroupMute

	// no validation rules for FriendMute

	// no validation rules for IsInIpWhiteList

	if all {
		switch v := interface{}(m.GetFreezeAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "FreezeAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "FreezeAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFreezeAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "FreezeAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FreezeBy

	// no validation rules for FreezeRemark

	if len(errors) > 0 {
		return UserInfoMultiError(errors)
	}

	return nil
}

// UserInfoMultiError is an error wrapping multiple validation errors returned
// by UserInfo.ValidateAll() if the designated constraints aren't met.
type UserInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoMultiError) AllErrors() []error { return m }

// UserInfoValidationError is the validation error returned by
// UserInfo.Validate if the designated constraints aren't met.
type UserInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoValidationError) ErrorName() string { return "UserInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoValidationError{}

// Validate checks the field values on UserInfoFunctionStatusList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInfoFunctionStatusList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfoFunctionStatusList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInfoFunctionStatusListMultiError, or nil if none found.
func (m *UserInfoFunctionStatusList) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfoFunctionStatusList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GroupMute

	// no validation rules for FriendMute

	// no validation rules for CreateGroup

	// no validation rules for AddFriend

	// no validation rules for FreezeAccount

	if len(errors) > 0 {
		return UserInfoFunctionStatusListMultiError(errors)
	}

	return nil
}

// UserInfoFunctionStatusListMultiError is an error wrapping multiple
// validation errors returned by UserInfoFunctionStatusList.ValidateAll() if
// the designated constraints aren't met.
type UserInfoFunctionStatusListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoFunctionStatusListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoFunctionStatusListMultiError) AllErrors() []error { return m }

// UserInfoFunctionStatusListValidationError is the validation error returned
// by UserInfoFunctionStatusList.Validate if the designated constraints aren't met.
type UserInfoFunctionStatusListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoFunctionStatusListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoFunctionStatusListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoFunctionStatusListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoFunctionStatusListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoFunctionStatusListValidationError) ErrorName() string {
	return "UserInfoFunctionStatusListValidationError"
}

// Error satisfies the builtin error interface
func (e UserInfoFunctionStatusListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfoFunctionStatusList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoFunctionStatusListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoFunctionStatusListValidationError{}

// Validate checks the field values on UserInfoIpItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfoIpItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfoIpItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoIpItemMultiError,
// or nil if none found.
func (m *UserInfoIpItem) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfoIpItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ip

	// no validation rules for IsProhibited

	if len(errors) > 0 {
		return UserInfoIpItemMultiError(errors)
	}

	return nil
}

// UserInfoIpItemMultiError is an error wrapping multiple validation errors
// returned by UserInfoIpItem.ValidateAll() if the designated constraints
// aren't met.
type UserInfoIpItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoIpItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoIpItemMultiError) AllErrors() []error { return m }

// UserInfoIpItemValidationError is the validation error returned by
// UserInfoIpItem.Validate if the designated constraints aren't met.
type UserInfoIpItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoIpItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoIpItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoIpItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoIpItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoIpItemValidationError) ErrorName() string { return "UserInfoIpItemValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoIpItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfoIpItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoIpItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoIpItemValidationError{}

// Validate checks the field values on UserInfoIpItemSet with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserInfoIpItemSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfoIpItemSet with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInfoIpItemSetMultiError, or nil if none found.
func (m *UserInfoIpItemSet) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfoIpItemSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetIpItem() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserInfoIpItemSetValidationError{
						field:  fmt.Sprintf("IpItem[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserInfoIpItemSetValidationError{
						field:  fmt.Sprintf("IpItem[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserInfoIpItemSetValidationError{
					field:  fmt.Sprintf("IpItem[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsMultiTerminalLogin

	if len(errors) > 0 {
		return UserInfoIpItemSetMultiError(errors)
	}

	return nil
}

// UserInfoIpItemSetMultiError is an error wrapping multiple validation errors
// returned by UserInfoIpItemSet.ValidateAll() if the designated constraints
// aren't met.
type UserInfoIpItemSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoIpItemSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoIpItemSetMultiError) AllErrors() []error { return m }

// UserInfoIpItemSetValidationError is the validation error returned by
// UserInfoIpItemSet.Validate if the designated constraints aren't met.
type UserInfoIpItemSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoIpItemSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoIpItemSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoIpItemSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoIpItemSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoIpItemSetValidationError) ErrorName() string {
	return "UserInfoIpItemSetValidationError"
}

// Error satisfies the builtin error interface
func (e UserInfoIpItemSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfoIpItemSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoIpItemSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoIpItemSetValidationError{}
